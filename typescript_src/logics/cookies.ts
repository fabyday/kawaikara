import { session } from 'electron';
import * as fs from 'fs/promises';
import { Cookie } from 'patchright';

export const getCookiesFromDomain = async (
    url: string,
): Promise<Electron.Cookie[]> => {
    const cookies = await session.defaultSession.cookies.get({
        domain: url,
    });

    return cookies;
};

/**
 * Convert Electron.Cookie[] to Netscape style Cookies string.
 * @param cookies @see getCookiesFromDomain
 * @returns Convert Electron.Cookie[] to Netscape style Cookies string.
 */
export function convertToNetscapeCookies(cookies: Electron.Cookie[]) {
    const header = [
        '# Netscape HTTP Cookie File',
        '# Generated by Electron for yt-dlp',
        '',
    ].join('\n');

    const cookieText = cookies
        .map((cookie) => {
            const domain = cookie.domain!.startsWith('.')
                ? cookie.domain
                : `.${cookie.domain}`;
            const subdomain = cookie.domain!.startsWith('.') ? 'TRUE' : 'FALSE';
            const path = cookie.path;
            const secure = cookie.secure ? 'TRUE' : 'FALSE';
            const expires = cookie.expirationDate
                ? Math.floor(cookie.expirationDate)
                : 0;
            const name = cookie.name;
            const value = cookie.value;

            return `${domain}\t${subdomain}\t${path}\t${secure}\t${expires}\t${name}\t${value}`;
        })
        .join('\n');

    return header + '\n' + cookieText;
}

export async function parseNetscapeCookies(cookieText: string) {
    const cookieString = cookieText
        .split('\n')
        .map((line) => {
            const parts = line.split('\t');
            if (parts.length < 7) {
                /// remove header and abnormal cases.
                return null;
            }
            const name = parts[5];
            const value = parts[6];
            return `${name}=${value}`;
        })
        .filter(Boolean)
        .join('; ');

    return cookieString;
}

export const getValidCookieFile = async (
    url: string,
    file_pth: string,
    validation_url: string,
): Promise<{ result: 'fail' | 'success'; cookie_string: string }> => {
    let cookie_string = '';
    try {
        await fs.access(file_pth);
        cookie_string = (await fs.readFile(file_pth)).toString();
        const cookie_key_value = await parseNetscapeCookies(cookie_string);

        if (
            await checkValidateCookieFromSite(cookie_key_value, validation_url)
        ) {
            return { result: 'success', cookie_string: cookie_string };
        } else {
            throw 'err';
        }
    } catch {
        // if File is Not exists on file_pth
        const cookies = await getCookiesFromDomain(url);
        cookie_string = await convertToNetscapeCookies(cookies);
        const promise_ = fs.writeFile(file_pth, cookie_string, 'utf-8');
        const cookie_key_value = await parseNetscapeCookies(cookie_string);
        let reval: 'fail' | 'success' = 'success';
        if (
            await checkValidateCookieFromSite(cookie_key_value, validation_url)
        ) {
            reval = 'success';
        }
        await promise_;
        return { result: reval, cookie_string: cookie_string };
    }
};

async function checkValidateCookieFromSite(
    cookie_string: string,
    url: string,
    user_agent?: string,
) {
    // const response = await fetch('https://www.youtube.com/getAccountInfo', {
    const response = await fetch(url, {
        headers: {
            Cookie: cookie_string,
            'User-Agent':
                user_agent ??
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        },
    });

    if (response.ok) {
        return true;
    }

    return false;
}

/**
 * convert playwright to electron cookie form.
 * @param cookie playwright cookie Object
 * @returns
 */
export async function convertPlayWrightCookieToElectron(
    cookie: Cookie,
): Promise<Electron.Cookie> {
    let sameSiteValue:
        | 'no_restriction'
        | 'lax'
        | 'strict'
        | 'unspecified'
        | undefined;

    if (cookie.sameSite === 'None') {
        sameSiteValue = 'no_restriction';
    } else if (cookie.sameSite === 'Lax') {
        sameSiteValue = 'lax';
    } else if (cookie.sameSite === 'Strict') {
        sameSiteValue = 'strict';
    } else {
        sameSiteValue = 'unspecified';
    }

    const cookieDetails = {
        url: `https://${cookie.domain.startsWith('.') ? cookie.domain.substring(1) : cookie.domain}${cookie.path}`,
        name: cookie.name,
        value: cookie.value,
        domain: cookie.domain,
        path: cookie.path,
        secure: cookie.secure,
        httpOnly: cookie.httpOnly,
        expirationDate: cookie.expires,
        sameSite: sameSiteValue,
    };

    return cookieDetails;
}

/**
 *
 * @param cookie
 * @returns playwright Cookie
 */
export async function convertElectronCookieToPlaywright(
    cookie: Electron.Cookie,
): Promise<Cookie> {
    let sameSiteValue: 'None' | 'Lax' | 'Strict' | 'unspecified' | undefined;

    if (cookie.sameSite === 'no_restriction') {
        sameSiteValue = 'None';
    } else if (cookie.sameSite === 'lax') {
        sameSiteValue = 'Lax';
    } else if (cookie.sameSite === 'strict') {
        sameSiteValue = 'Strict';
    } else {
        sameSiteValue = 'None';
    }

    const cookieDetails: Cookie = {
        name: cookie.name,
        value: cookie.value,
        domain: cookie.domain ?? '',
        path: cookie.path ?? '/',
        secure: cookie.secure ?? false,
        httpOnly: cookie.httpOnly ?? false,
        expires: cookie.expirationDate ?? 0,
        sameSite: sameSiteValue,
    };
    return cookieDetails;
}
