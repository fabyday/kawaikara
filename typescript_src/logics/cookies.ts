import { session } from 'electron';
import * as fs from 'fs/promises';

export const getCookiesFromDomain = async (
    url: string,
): Promise<Electron.Cookie[]> => {
    const cookies = await session.defaultSession.cookies.get({
        domain: url,
    });

    return cookies;
};

/**
 * Convert Electron.Cookie[] to Netscape style Cookies string.
 * @param cookies @see getCookiesFromDomain
 * @returns Convert Electron.Cookie[] to Netscape style Cookies string.
 */
export function convertToNetscapeCookies(cookies: Electron.Cookie[]) {
    const header = [
        '# Netscape HTTP Cookie File',
        '# Generated by Electron for yt-dlp',
        '',
    ].join('\n');

    const cookieText = cookies
        .map((cookie) => {
            const domain = cookie.domain!.startsWith('.')
                ? cookie.domain
                : `.${cookie.domain}`;
            const subdomain = cookie.domain!.startsWith('.') ? 'TRUE' : 'FALSE';
            const path = cookie.path;
            const secure = cookie.secure ? 'TRUE' : 'FALSE';
            const expires = cookie.expirationDate
                ? Math.floor(cookie.expirationDate)
                : 0;
            const name = cookie.name;
            const value = cookie.value;

            return `${domain}\t${subdomain}\t${path}\t${secure}\t${expires}\t${name}\t${value}`;
        })
        .join('\n');

    return header + '\n' + cookieText;
}

export async function parseNetscapeCookies(cookieText: string) {
    const cookieString = cookieText
        .split('\n')
        .map((line) => {
            const parts = line.split('\t');
            if (parts.length < 7) {
                /// remove header and abnormal cases.
                return null;
            }
            const name = parts[5];
            const value = parts[6];
            return `${name}=${value}`;
        })
        .filter(Boolean)
        .join('; ');

    return cookieString;
}

export const getValidCookieFile = async (
    url: string,
    file_pth: string,
    validation_url: string,
): Promise<'fail' | 'success'> => {
    let cookie_string = '';
    try {
        await fs.access(file_pth);
        cookie_string = (await fs.readFile(file_pth)).toString();
        const cookie_key_value = await parseNetscapeCookies(cookie_string);

        if (
            await checkValidateCookieFromSite(cookie_key_value, validation_url)
        ) {
            return 'success';
        } else {
            throw 'err';
        }
    } catch {
        // if File is Not exists on file_pth
        const cookies = await getCookiesFromDomain(url);
        cookie_string = await convertToNetscapeCookies(cookies);
        const promise_ = fs.writeFile(file_pth, cookie_string, 'utf-8');
        const cookie_key_value = await parseNetscapeCookies(cookie_string);
        let reval: 'fail' | 'success' = 'fail';
        if (
            await checkValidateCookieFromSite(cookie_key_value, validation_url)
        ) {
            reval = 'success';
        }
        await promise_;
        return reval;
    }
};

async function checkValidateCookieFromSite(
    cookie_string: string,
    url: string,
    user_agent?: string,
) {
    // const response = await fetch('https://www.youtube.com/getAccountInfo', {
    const response = await fetch(url, {
        headers: {
            Cookie: cookie_string,
            'User-Agent':
                user_agent ??
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        },
    });

    if (response.ok) {
        return true;
    }

    return false;
}
